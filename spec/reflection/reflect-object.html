<!doctype html>
<es-clause title="The Reflect Object" anchor="sec-reflect-object">
  <p>The Reflect object is a single ordinary object.</p>

  <p>The value of the [[Prototype]] <es-xref target=
  "sec-object-internal-methods-and-internal-slots">internal slot</es-xref> of the Reflect object is
  the standard built-in Object prototype object (<es-xref target=
  "sec-properties-of-the-object-prototype-object">19.1.3</es-xref>).</p>

  <p>The Reflect object is not a function object. It does not have a [[Construct]] internal method;
  it is not possible to use the Reflect object as a constructor with the <code>new</code> operator.
  The Reflect object also does not have a [[Call]] internal method; it is not possible to invoke
  the Reflect object as a function.</p>

  <es-clause title="Reflect.defineProperty(target, propertyKey, attributes)" anchor=
  "sec-reflect.defineproperty">
    <p>When the <code>defineProperty</code> function is called with arguments <i>target</i>,
    <i>propertyKey</i>, and <es-nt>attributes</es-nt> the following steps are taken:</p>

    <ol class="proc">
      <li>Let <i>obj</i> be <es-xref target="sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

      <li>Let <i>key</i> be <es-xref target=
      "sec-topropertykey">ToPropertyKey</es-xref>(<i>propertyKey</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>key</i>).</li>

      <li>Let <i>desc</i> be the result of calling <es-xref target=
      "sec-topropertydescriptor">ToPropertyDescriptor</es-xref> with <i>attributes</i> as the
      argument.</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>desc</i>).</li>

      <li>Return the result of calling the [[DefineOwnProperty]] internal method of <i>obj</i> with
      arguments <i>key</i>, and <i>desc</i>.</li>
    </ol>
  </es-clause>

  <es-clause title="Reflect.deleteProperty (target, propertyKey)" anchor=
  "sec-reflect.deleteproperty">
    <p>When the <code>deleteProperty</code> function is called with arguments <i>target</i> and
    <i>propertyKey</i>, the following steps are taken:</p>

    <ol class="proc">
      <li>Let <i>obj</i> be <es-xref target="sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

      <li>Let <i>key</i> be <es-xref target=
      "sec-topropertykey">ToPropertyKey</es-xref>(<i>propertyKey</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>key</i>).</li>

      <li>Return the result of calling the [[Delete]] internal method of <i>obj</i> with argument
      <i>key</i>.</li>
    </ol>
  </es-clause>

  <es-clause title="Reflect.enumerate (target)" anchor="sec-reflect.enumerate">
    <p>When the <code>enumerate</code> function is called with argument <es-nt>target</es-nt> the
    following steps are taken:</p>

    <ol class="proc">
      <li>Let <i>obj</i> be <es-xref target="sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

      <li>Let <i>iterator</i> be the result of calling the [[Enumerate]] internal method of
      <i>obj</i>.</li>

      <li>Return <i>iterator</i>.</li>
    </ol>
  </es-clause>

  <es-clause title="Reflect.get (target, propertyKey, receiver=target)" anchor="sec-reflect.get">
    <p>When the <code>get</code> function is called with arguments <i>target</i>,
    <i>propertyKey</i>, and <es-nt>receiver</es-nt> the following steps are taken:</p>

    <ol class="proc">
      <li>Let <i>obj</i> be <es-xref target="sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

      <li>Let <i>key</i> be <es-xref target=
      "sec-topropertykey">ToPropertyKey</es-xref>(<i>propertyKey</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>key</i>).</li>

      <li>If <i>receiver</i> is not present, then

        <ol class="block">
          <li>Let <i>receiver</i> be <i>target</i>.</li>
        </ol>
      </li>

      <li>Return the result of calling the [[Get]] internal method of <i>obj</i> with arguments
      <i>key</i>, and <i>receiver</i>.</li>
    </ol>
  </es-clause>

  <es-clause title="Reflect.getOwnPropertyDescriptor(target, propertyKey)" anchor=
  "sec-reflect.getownpropertydescriptor">
    <p>When the <code>getOwnPropertyDescriptor</code> function is called with arguments
    <i>target</i> and <i>propertyKey</i>, the following steps are taken:</p>

    <ol class="proc">
      <li>Let <i>obj</i> be <es-xref target="sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

      <li>Let <i>key</i> be <es-xref target=
      "sec-topropertykey">ToPropertyKey</es-xref>(<i>propertyKey</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>key</i>).</li>

      <li>Let <i>desc</i> be the result of calling the [[GetOwnProperty]] internal method of
      <i>obj</i> with argument <i>key</i>.</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>desc</i>).</li>

      <li>Return the result of calling <es-xref target=
      "sec-frompropertydescriptor">FromPropertyDescriptor</es-xref>(<i>desc</i>).</li>
    </ol>
  </es-clause>

  <es-clause title="Reflect.getPrototypeOf (target)" anchor="sec-reflect.getprototypeof">
    <p>When the <code>getPrototypeOf</code> function is called with argument <es-nt>target</es-nt>
    the following steps are taken:</p>

    <ol class="proc">
      <li>Let <i>obj</i> be <es-xref target="sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

      <li>Return the result of calling the [[GetPrototypeOf]] internal method of <i>obj</i>.</li>
    </ol>
  </es-clause>

  <es-clause title="Reflect.has (target, propertyKey)" anchor="sec-reflect.has">
    <p>When the <code>has</code> function is called with arguments <i>target</i> and
    <i>propertyKey</i>, the following steps are taken:</p>

    <ol class="proc">
      <li>Let <i>obj</i> be <es-xref target="sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

      <li>Let <i>key</i> be <es-xref target=
      "sec-topropertykey">ToPropertyKey</es-xref>(<i>propertyKey</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>key</i>).</li>

      <li>Return the result of calling the [[HasProperty]] internal method of <i>obj</i> with
      argument <i>key</i>.</li>
    </ol>
  </es-clause>

  <es-clause title="Reflect.hasOwn (target, propertyKey)" anchor="sec-reflect.hasown">
    <p>When the <code>hasOwn</code> function is called with arguments <i>target</i> and
    <i>propertyKey</i>, the following steps are taken:</p>

    <ol class="proc">
      <li>Let <i>obj</i> be <es-xref target="sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

      <li>Let <i>key</i> be <es-xref target=
      "sec-topropertykey">ToPropertyKey</es-xref>(<i>propertyKey</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>key</i>).</li>

      <li>Return the result of <es-xref target=
      "sec-hasownproperty">HasOwnProperty</es-xref>(<i>obj</i>, <i>key</i>).</li>
    </ol>
  </es-clause>

  <es-clause title="Reflect.isExtensible (target)" anchor="sec-reflect.isextensible">
    <p>When the <code>isExtensible</code> function is called with argument <es-nt>target</es-nt>
    the following steps are taken:</p>

    <ol class="proc">
      <li>Let <i>obj</i> be <es-xref target="sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

      <li>Return the result of calling the [[IsExtensible]] internal method of <i>obj</i>.</li>
    </ol>
  </es-clause>

  <es-clause title="Reflect.ownKeys (target)" anchor="sec-reflect.ownkeys">
    <p>When the <code>ownKeys</code> function is called with argument <es-nt>target</es-nt> the
    following steps are taken:</p>

    <ol class="proc">
      <li>Let <i>obj</i> be <es-xref target="sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

      <li>Return the result of calling the [[OwnPropertyKeys]] internal method of <i>obj</i>.</li>
    </ol>
  </es-clause>

  <es-clause title="Reflect.preventExtensions (target)" anchor="sec-reflect.preventextensions">
    <p>When the <code>preventExtensions</code> function is called with argument
    <es-nt>target</es-nt>, the following steps are taken:</p>

    <ol class="proc">
      <li>Let <i>obj</i> be <es-xref target="sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

      <li>Return the result of calling the [[PreventExtensions]] internal method of
      <i>obj</i>.</li>
    </ol>
  </es-clause>

  <es-clause title="Reflect.set (target, propertyKey, V, receiver=target)" anchor=
  "sec-reflect.set">
    <p>When the <code>set</code> function is called with arguments <i>target</i>, <i>V</i>,
    <i>propertyKey</i>, and <es-nt>receiver</es-nt> the following steps are taken:</p>

    <ol class="proc">
      <li>Let <i>obj</i> be <es-xref target="sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

      <li>Let <i>key</i> be <es-xref target=
      "sec-topropertykey">ToPropertyKey</es-xref>(<i>propertyKey</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>key</i>).</li>

      <li>If <i>receiver</i> is not present, then

        <ol class="block">
          <li>Let <i>receiver</i> be <i>target</i>.</li>
        </ol>
      </li>

      <li>Return the result of calling the [[Set]] internal method of <i>obj</i> with arguments
      <i>key</i>, <i>V</i>, and <i>receiver</i>.</li>
    </ol>
  </es-clause>

  <es-clause title="Reflect.setPrototypeOf (target, proto)" anchor="sec-reflect.setprototypeof">
    <p>When the <code>setPrototypeOf</code> function is called with arguments <i>target</i> and
    <i>propertyKey</i>, the following steps are taken:</p>

    <ol class="proc">
      <li>Let <i>obj</i> be <es-xref target="sec-toobject">ToObject</es-xref>(<i>target</i>).</li>

      <li><es-xref target="sec-returnifabrupt">ReturnIfAbrupt</es-xref>(<i>obj</i>).</li>

      <li>If <es-xref target="sec-ecmascript-data-types-and-values">Type</es-xref>(<i>proto</i>) is
      not Object and <i>proto</i> is not <b>null</b>, then throw a <b>TypeError</b> exception</li>

      <li>Return the result of calling the [[SetPrototypeOf]] internal method of <i>obj</i> with
      argument <i>proto</i>.</li>
    </ol>
  </es-clause>
</es-clause>

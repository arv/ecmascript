<!doctype html>
<es-clause title="Algorithm Conventions" anchor="sec-algorithm-conventions">
  <p>The specification often uses a numbered list to specify steps in an algorithm. These
  algorithms are used to precisely specify the required semantics of ECMAScript language
  constructs. The algorithms are not intended to imply the use of any specific implementation
  technique. In practice, there may be more efficient algorithms available to implement a given
  feature.</p>

  <p>Algorithms may be explicitly parameterised, in which case the names and usage of the
  parameters must be provided as part of the algorithm’s definition. In order to facilitate their
  use in multiple parts of this specification, some algorithms, called <i>abstract</i>
  <i>operations</i>, are named and written in parameterised functional form so that they may be
  referenced by name from within other algorithms.</p>

  <p>Algorithms may be associated with productions of one of the ECMAScript grammars. A production
  that has multiple alternative definitions will typically have a distinct algorithm for each
  alternative. When an algorithm is associated with a grammar production, it may reference the
  terminal and nonterminal symbols of the production alternative as if they were parameters of the
  algorithm. When used in this manner, nonterminal symbols refer to the actual alternative
  definition that is matched when parsing the script souce code.</p>

  <p>When an algorithm is associated with a production alternative, the alternative is typically
  shown without any “[ ]” grammar annotations. Such annotations should only affect the syntactic
  recognition of the alternative and have no effect on the associated semantics for the
  alternative.</p>

  <p>Unless explicitly specified otherwise, all <a href="#sec-context-free-grammars">chain
  productions</a> have an implicit associated definition for every algorithm that is might be
  applied to that production’s left-hand side nonterminal. The implicit definition simply reapplies
  the same algorithm name with the same parameters, if any, to the <a href=
  "#sec-context-free-grammars">chain production</a> ’s sole right-hand side nonterminal and then
  result. For example, assume there is a production</p>

  <es-production name="Block">
    <es-rhs><es-t>{</es-t> <es-nt>StatementList</es-nt> <es-t>}</es-t></es-rhs>
  </es-production>

  <p>but there is no evalution algorithm that is explicitly specified for that production. If in
  some algorithm there is a statement of the form: “Return the result of evaluating <i>Block</i>”
  it is implicit that the algorithm has an evalution algorithm of the form:</p>

  <p><b>Runtime Semantics: Evaluation</b></p>

  <es-production name="Block" class="inline">
    <es-rhs><es-t>{</es-t> <es-nt>StatementList</es-nt> <es-t>}</es-t></es-rhs>
  </es-production>

  <ol class="proc">
    <li>Return the result of evaluating StatementList.</li>
  </ol>

  <p>For clarity of expression, algorithm steps may be subdivided into sequential substeps.
  Substeps are indented and may themselves be further divided into indented substeps. Outline
  numbering conventions are used to identify substeps with the first level of substeps labelled
  with lower case alphabetic characters and the second level of substeps labelled with lower case
  roman numerals. If more than three levels are required these rules repeat with the fourth level
  using numeric labels. For example:</p>

  <p><span class="marker"></span>Top-level step</p>

  <ol class="proc">
    <li>Substep.</li>

    <li>Substep.

      <ol class="block">
        <li>Subsubstep.

          <ol class="block">
            <li>Subsubsubstep

              <ol class="block">
                <li>Subsubsubsubstep

                  <ol class="block">
                    <li>Subsubsubsubsubstep</li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>

  <p>A step or substep may be written as an “if” predicate that conditions its substeps. In this
  case, the substeps are only applied if the predicate is true. If a step or substep begins with
  the word “else”, it is a predicate that is the negation of the preceding “if” predicate step at
  the same level.</p>

  <p>A step may specify the iterative application of its substeps.</p>

  <p>A step may assert an invariant condition of its algorithm. Such assertions are used to make
  explicit algorithmic invariants that would otherwise be implicit. Such assertions add no
  additional semantic requirements and hence need not be checked by an implementation. They are
  used simply to clarify algorithms.</p>

  <p>Mathematical operations such as addition, subtraction, negation, multiplication, division, and
  the mathematical functions defined later in this clause should always be understood as computing
  exact mathematical results on mathematical real numbers, which do not include infinities and do
  not include a negative zero that is distinguished from positive zero. Algorithms in this standard
  that model floating-point arithmetic include explicit steps, where necessary, to handle
  infinities and signed zero and to perform rounding. If a mathematical operation or function is
  applied to a floating-point number, it should be understood as being applied to the exact
  mathematical value represented by that floating-point number; such a floating-point number must
  be finite, and if it is <span class="value">+0</span> or <span class="value">−0</span> then the
  corresponding mathematical value is simply <span class="value">0</span>.</p>

  <p>The mathematical function abs(<i>x</i>) produces the absolute value of <es-nt>x</es-nt>, which
  is −<i>x</i> if <es-nt>x</es-nt> is negative (less than zero) and otherwise is <es-nt>x</es-nt>
  itself.</p>

  <p>The mathematical function sign(<i>x</i>) produces 1 if <es-nt>x</es-nt> is positive and −1 if
  <es-nt>x</es-nt> is negative. The sign function is not used in this standard for cases when
  <es-nt>x</es-nt> is zero.</p>

  <p>The mathematical function min(<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, ...,
  <i>x</i><sub>n</sub>) produces the mathematically smallest of <i>x</i><sub>1</sub> through
  <i>x</i><sub>n</sub>.</p>

  <p>The notation “<i>x</i> modulo <i>y</i>” (<es-nt>y</es-nt> must be finite and nonzero) computes
  a value <es-nt>k</es-nt> of the same sign as <es-nt>y</es-nt> (or zero) such that abs(<i>k</i>)
  &lt; abs(<i>y</i>) and <i>x</i>−<i>k</i> = <i>q</i> × <es-nt>y</es-nt> for some integer
  <es-nt>q</es-nt>.</p>

  <p>The mathematical function floor(<i>x</i>) produces the largest integer (closest to positive
  infinity) that is not larger than <es-nt>x</es-nt>.</p>

  <es-note>
    <p>floor(<i>x</i>) = <i>x</i>−(<i>x</i> modulo 1).</p>
  </es-note>
</es-clause>

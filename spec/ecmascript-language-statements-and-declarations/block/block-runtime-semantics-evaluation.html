<!doctype html>
<es-clause title="Runtime Semantics: Evaluation" anchor="sec-block-runtime-semantics-evaluation">
  <es-production name="Block" class="inline">
    <es-rhs>{ }</es-rhs>
  </es-production>

  <ol class="proc">
    <li>Return <a href="#sec-normalcompletion">NormalCompletion</a> (<b>undefined</b>).
    </li>
  </ol>

  <es-production name="Block" class="inline">
    <es-rhs><es-t>{</es-t> <es-nt>StatementList</es-nt> <es-t>}</es-t></es-rhs>
  </es-production>

  <ol class="proc">
    <li>Let <i>oldEnv</i> be <a href="#sec-execution-contexts">the running execution context</a> ’s
    <a href="#sec-execution-contexts">LexicalEnvironment</a> .
    </li>

    <li>Let <i>blockEnv</i> be the result of calling <a href=
    "#sec-newdeclarativeenvironment">NewDeclarativeEnvironment</a> passing <i>oldEnv</i> as the
    argument.
    </li>

    <li>Perform Block Declaration Instantiation using <i>StatementList</i> and
    <i>blockEnv</i>.</li>

    <li>Set <a href="#sec-execution-contexts">the running execution context</a> ’s <a href=
    "#sec-execution-contexts">LexicalEnvironment</a> to <i>blockEnv</i>.
    </li>

    <li>Let <i>blockValue</i> be the result of evaluating <i>StatementList</i>.</li>

    <li>Set <a href="#sec-execution-contexts">the running execution context</a> ’s <a href=
    "#sec-execution-contexts">LexicalEnvironment</a> to <i>oldEnv</i>.
    </li>

    <li>If <i>blockValue</i>.[[type]] is normal and <i>blockValue</i>.[[value]] is empty, then

      <ol class="block">
        <li>Return <a href="#sec-normalcompletion">NormalCompletion</a> (<b>undefined</b>).
        </li>
      </ol>
    </li>

    <li>Return <i>blockValue</i>.</li>
  </ol>

  <es-note>
    <p>No matter how control leaves the <es-nt>Block</es-nt> the <a href=
    "#sec-execution-contexts">LexicalEnvironment</a> is always restored to its former state.</p>
  </es-note>

  <es-production name="StatementList" class="inline">
    <es-rhs><es-nt>StatementList</es-nt> <es-nt>StatementListItem</es-nt></es-rhs>
  </es-production>

  <ol class="proc">
    <li>Let <i>sl</i> be the result of evaluating <i>StatementList</i>.</li>

    <li>
      <a href="#sec-returnifabrupt">ReturnIfAbrupt</a> (<i>sl</i>).
    </li>

    <li>Let <i>s</i> be the result of evaluating <i>StatementListItem</i>.</li>

    <li>If <i>s</i>.[[type]] is throw, return <i>s</i>.</li>

    <li>If <i>s</i>.[[value]] is empty, let <i>V</i> = <i>sl</i>.[[value]], otherwise let <i>V</i>
    = <i>s</i>.[[value]].</li>

    <li>Return <a href="#sec-completion-record-specification-type">Completion</a> {[[type]]:
    <i>s</i>.[[type]], [[value]]: <i>V</i>, [[target]]: <i>s</i>.[[target]]}.
    </li>
  </ol>

  <es-note>
    <p>Steps 5 and 6 of the above algorithm ensure that the value of a <es-nt>StatementList</es-nt>
    is the value of the last value producing <i>Statement</i> in the <es-nt>StatementList</es-nt>.
    For example, the following calls to the <code>eval</code> function all return the value 1:</p>
    <pre>
eval("1;;;;;")
</pre>
    <pre>
eval("1;{}")
</pre>
    <pre>
eval("1;var a;")
</pre>
  </es-note>
</es-clause>
